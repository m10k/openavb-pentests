/*
 * This file is part of openavb-pentests
 * Copyright (C) 2016 Matthias Kruk
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. 
 */

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>
#include <netpacket/packet.h>
#include <net/ethernet.h>
#include <linux/if.h>
#include "common.h"
#include "list.h"

unsigned char HWADDR[6] = { 0x00, 0x88, 0x77, 0x66, 0x55, 0x44 };
unsigned char MMRP_ADDR[] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x20 };
unsigned char MVRP_ADDR[] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x21 };

#define MIN(a,b) ((a) < (b) ? (a) : (b))

struct mrp_msg {
    uint8_t  type;
    uint8_t  attr_len;
  
    uint8_t  data[1024];
    size_t   dlen;
};

struct mrp {
    uint8_t  ver;
    list_t   *msgs;
    uint16_t endmark;
};

struct mrp_socket {
    int fd;
    char *dst;
    uint16_t type;
    char hwaddr[6];
};

mrp_msg_t* mrp_msg_new(uint8_t type, uint8_t attr_len)
{
    mrp_msg_t *msg;

    if((msg = malloc(sizeof(*msg)))) {
	memset(msg, 0, sizeof(*msg));
	msg->type = type;
	msg->attr_len = attr_len;
    }

    return(msg);
}

int mrp_msg_append(mrp_msg_t *msg, void *data, size_t len)
{
    if(len + msg->dlen > sizeof(msg->data)) {
	errno = EMSGSIZE;
	return(-1);
    }

    memcpy(msg->data + msg->dlen, data, len);
    msg->dlen += len;

    return(0);
}

void mrp_msg_len(struct mrp_msg *msg, size_t *size)
{
    *size += 2 + msg->dlen;
    return;
}

void mrp_msg_raw(struct mrp_msg *msg, char **ptr)
{
    size_t len = 2 + msg->dlen;
  
    memcpy(*ptr, msg, len);
    *ptr += len;

    return;
}

mrp_t* mrp_new(uint8_t ver)
{
    mrp_t *m;

    if((m = malloc(sizeof(*m)))) {
	memset(m, 0, sizeof(*m));

	m->ver = ver;
    }

    return(m);
}

void mrp_free(mrp_t *m)
{
    list_foreach(&(m->msgs), free);
    list_free(&(m->msgs));
    free(m);
  
    return;
}

int mrp_append(mrp_t *m, mrp_msg_t *msg)
{
    list_append(&(m->msgs), msg);

    return(0);
}

ssize_t mrp_raw(mrp_t *m, void *buf, size_t n)
{
    ssize_t off;
    size_t size_req;
    char *dst, *ptr;

    size_req = 3;
    off = 0;
    dst = (char*)buf;
  
    list_foreach2(&(m->msgs), (void(*)(void*,void*))mrp_msg_len, &size_req);

    if(n < size_req) {
	errno = EOVERFLOW;
	return(-1);
    }

    dst[off++] = m->ver;
    ptr = dst + off;

    list_foreach2(&(m->msgs), (void(*)(void*,void*))mrp_msg_raw, &ptr);

    *((uint16_t*)ptr) = 0;

    off = ptr - dst + 2;
    errno = 0;
    return(off);
}

struct mrp_socket* mrp_socket_open(uint16_t type, const char *iface)
{
    struct mrp_socket *sock;
    void *mcast_addr;
    struct sockaddr_ll ll;
    struct packet_mreq mreq;
    struct ifreq ifr;
    int err;

    sock = NULL;
    mcast_addr = NULL;
    err = 0;
    
    switch(type) {
    case PROTO_MMRP:
	mcast_addr = MMRP_ADDR;
	break;
    case PROTO_MVRP:
	mcast_addr = MVRP_ADDR;
	break;
    default:
	err = EINVAL;
	goto cleanup;
    }

    if((sock = malloc(sizeof(*sock)))) {
	sock->dst = mcast_addr;
	sock->type = type;
	
	if((sock->fd = socket(PF_PACKET, SOCK_RAW, htons(type))) < 0) {
	    err = errno;
	    perror("socket");
	    goto cleanup;
	}

	memset(&ll, 0, sizeof(ll));
	memset(&ifr, 0, sizeof(ifr));

	snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "%s", iface);
	if(ioctl(sock->fd, SIOCGIFHWADDR, &ifr) < 0) {
	    err = errno;
	    perror("ioctl");
	    goto cleanup;
	}

	memcpy(sock->hwaddr, ifr.ifr_hwaddr.sa_data, sizeof(sock->hwaddr));
	memset(&ifr, 0, sizeof(ifr));
	snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "%s", iface);

	if(ioctl(sock->fd, SIOCGIFINDEX, &ifr) < 0) {
	    err = errno;
	    perror("ioctl");
	    goto cleanup;
	}

	ll.sll_ifindex = ifr.ifr_ifindex;
	ll.sll_family = AF_PACKET;
	ll.sll_protocol = htons(type);

	if(bind(sock->fd, (struct sockaddr*)&ll, sizeof(ll)) < 0) {
	    err = errno;
	    perror("bind");
	    goto cleanup;
	}

	if(setsockopt(sock->fd, SOL_SOCKET, SO_BINDTODEVICE, iface, strlen(iface)) < 0) {
	    err = errno;
	    perror("setsockopt");
	    goto cleanup;
	}

	memset(&mreq, 0, sizeof(mreq));
	mreq.mr_ifindex = ifr.ifr_ifindex;
	mreq.mr_type = PACKET_MR_MULTICAST;
	mreq.mr_alen = 6;
	memcpy(mreq.mr_address, mcast_addr, mreq.mr_alen);

	if(setsockopt(sock->fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) < 0) {
	    err = errno;
	    perror("setsockopt");
	    goto cleanup;
	}
    }

 cleanup:
    if(err) {
	if(sock) {
	    if(sock->fd >= 0) {
		close(sock->fd);
	    }
	    
	    free(sock);
	    sock = NULL;
	}
	
	errno = err;
    }
    
    return(sock);
}

int mrp_socket_send(struct mrp_socket *so, const void *data, size_t n)
{
    uint8_t buf[ETHERMTU];

    memcpy(buf, so->hwaddr, 6);
    memcpy(buf + 6, so->dst, 6);
    *((uint16_t*)(buf + 12)) = htons(so->type);
    memcpy(buf + 14, data, MIN(n, ETHERMTU - 14));

    return(send(so->fd, buf, MIN(n + 14, ETHERMTU), 0));
}

int mrp_socket_close(struct mrp_socket *so)
{
    if(so->fd >= 0) {
	close(so->fd);
    }
    free(so);

    return(0);
}
