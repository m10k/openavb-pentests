#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>
#include <netpacket/packet.h>
#include <net/ethernet.h>
#include <linux/if.h>
#include "common.h"
#include "list.h"

unsigned char HWADDR[6] = { 0x00, 0x88, 0x77, 0x66, 0x55, 0x44 };
unsigned char MMRP_ADDR[] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x20 };
unsigned char MVRP_ADDR[] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x21 };

struct mmrp_msg {
  uint8_t  type;
  uint8_t  attr_len;
  uint16_t attr_list_len;
};

struct mmrp {
  uint8_t  ver;
  list_t   *msgs;
  uint16_t endmark;
};

void mmrp_msg_len(struct mmrp_msg *msg, size_t *size)
{
  *size += sizeof(*msg);
  return;
}

void mmrp_msg_raw(struct mmrp_msg *msg, char **ptr)
{
  memcpy(*ptr, msg, sizeof(*msg));
  *ptr += sizeof(*msg);

  return;
}

mmrp_t* mmrp_new(uint8_t ver)
{
  mmrp_t *m;

  if((m = malloc(sizeof(*m)))) {
    memset(m, 0, sizeof(*m));

    m->ver = ver;
  }

  return(m);
}

void mmrp_free(mmrp_t *m)
{
  list_foreach(&(m->msgs), free);
  list_free(&(m->msgs));
  free(m);
  
  return;
}

int mmrp_msg_append(mmrp_t *m, uint8_t type, uint8_t alen, uint16_t allen)
{
  struct mmrp_msg *msg;

  if(!(msg = malloc(sizeof(*msg)))) {
    return(-1);
  }

  msg->type = type;
  msg->attr_len = alen;
  msg->attr_list_len = allen;

  list_append(&(m->msgs), msg);

  return(0);
}

ssize_t mmrp_raw(mmrp_t *m, void *buf, size_t n)
{
  ssize_t off;
  size_t size_req;
  char *dst, *ptr;

  size_req = 3;
  off = 0;
  dst = (char*)buf;
  
  list_foreach2(&(m->msgs), (void(*)(void*,void*))mmrp_msg_len, &size_req);

  if(n < size_req) {
    errno = EOVERFLOW;
    return(-1);
  }

  dst[off++] = m->ver;
  ptr = dst + off;

  list_foreach2(&(m->msgs), (void(*)(void*,void*))mmrp_msg_raw, &ptr);

  *((uint16_t*)ptr) = 0;

  off = ptr - dst + 2;
  errno = 0;
  return(off);
}

int net_socket(int type, const char *iface)
{
  int err;
  int so;
  struct sockaddr_ll addr;
  struct packet_mreq req;
  struct ifreq ifr;
  void *mcast_addr;

  switch(type) {
  case PROTO_MMRP:
    mcast_addr = MMRP_ADDR;
    break;
  default:
    mcast_addr = NULL;
  }

  if(!mcast_addr) {
    errno = EINVAL;
    return(-1);
  }

  if((so = socket(PF_PACKET, SOCK_RAW, htons(type))) < 0) {
    perror("socket");
    return(-1);
  }

  memset(&addr, 0, sizeof(addr));
  memset(&ifr, 0, sizeof(ifr));

  snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "%s", iface);

  if(ioctl(so, SIOCGIFHWADDR, &ifr) < 0) {
    perror("ioctl");
    err = errno;
    close(so);
    errno = err;
    return(-1);
  }
  
  memcpy(HWADDR, ifr.ifr_hwaddr.sa_data, sizeof(HWADDR));
  printf("HWADDR: %02x:%02x:%02x:%02x:%02x:%02x", HWADDR[0], HWADDR[1], HWADDR[2], HWADDR[3], HWADDR[4], HWADDR[5]);
  
  memset(&ifr, 0, sizeof(ifr));
  snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "%s", iface);

  if(ioctl(so, SIOCGIFINDEX, &ifr) < 0) {
    perror("ioctl");
    err = errno;
    close(so);
    errno = err;
    return(-1);
  }

  printf(" [ifidx %d]\n", ifr.ifr_ifindex);

  /*
  memcpy(addr.sll_addr, HWADDR, sizeof(HWADDR));
  addr.sll_halen = sizeof(HWADDR);
  */
  addr.sll_ifindex = ifr.ifr_ifindex;
  addr.sll_family = AF_PACKET;
  addr.sll_protocol = htons(type);

  if(bind(so, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
    perror("bind");
    err = errno;
    close(so);
    errno = err;
    return(-1);
  }

  if(setsockopt(so, SOL_SOCKET, SO_BINDTODEVICE, iface, strlen(iface)) < 0) {
    perror("setsockopt");
    err = errno;
    close(so);
    errno = err;
    return(-1);
  }

  memset(&req, 0, sizeof(req));
  req.mr_ifindex = ifr.ifr_ifindex;
  req.mr_type = PACKET_MR_MULTICAST;
  req.mr_alen = 6;
  memcpy(req.mr_address, mcast_addr, req.mr_alen);

  if(setsockopt(so, SOL_PACKET, PACKET_ADD_MEMBERSHIP, &req, sizeof(req)) < 0) {
    perror("setsockopt");
    err = errno;
    close(so);
    errno = err;
    return(-1);
  }
  
  return(so);
}

int net_write(int so, const void *src, const void *dst, unsigned short type, const char *data, size_t n)
{
  uint8_t buf[1600];

  memcpy(buf, src, 6);
  memcpy(buf + 6, dst, 6);
  *((uint16_t*)(buf + 12)) = htons(type);
  memcpy(buf + 14, data, n);
  
  return(send(so, buf, n + 14, 0));
}

int net_close(int so)
{
  close(so);
  return(0);
}

int mmrp_send(int so, const char *buf, size_t n)
{
  return(net_write(so, MMRP_ADDR, HWADDR, PROTO_MMRP, buf, n));
}
