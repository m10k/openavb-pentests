#include <sys/socket.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <net/ethernet.h>
#include <arpa/inet.h>
#include <netpacket/packet.h>
#include <errno.h>
#include <endian.h>

#define PTP_ETHERTYPE 0x88F7

struct announce {
  uint16_t type;
  uint16_t len;
  uint16_t subdomain;
  uint16_t flags;
  uint64_t correction;
  uint32_t _resv0;
  uint64_t clockid;
  uint16_t sport;
  uint16_t seq;
  uint8_t  control;
  uint8_t  lmp;
  uint16_t _resv1;
  uint64_t _resv2;
  uint16_t offset;
  uint8_t  _recv3;
  uint8_t  prio;
  uint8_t  gcc;
  uint8_t  gca;
  uint16_t variance;
  uint8_t  prio2;
  uint64_t grandmaster;
  uint16_t localsr;
  uint8_t  tsc;
  uint16_t pt;
  uint16_t ptlen;
} __attribute__((packed));

#define CLOCK_ID 0x00a0c9fffffe0000LL

int announce(int sock, int iface, struct announce *msg)
{
  struct sockaddr_ll addr;
  uint8_t mcast_addr[] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x0E };
  int ret_val = -EINVAL;

  addr.sll_family = AF_PACKET;
  addr.sll_protocol = htons(PTP_ETHERTYPE);
  addr.sll_ifindex = iface;
  addr.sll_halen = ETH_ALEN;
  memcpy(&(addr.sll_addr), mcast_addr, sizeof(mcast_addr));

  ret_val = sendto(sock, msg, sizeof(*msg), 0,
		   (struct sockaddr*)&addr, sizeof(addr));

  if(ret_val < 0) {
    ret_val = -errno;
    perror("sendto");
  }

  return(ret_val);
}

int main(int argc, char *argv[])
{
  struct announce msg;
  int sock;
  unsigned char hwaddr[7];
  int ret_val;
  struct ifreq req;
  struct sockaddr_ll addr;
  int i;

  memset(&msg, 0, sizeof(msg));
  msg.type = htons(0x0b02); /* 1b02 */
  msg.len = htons(sizeof(msg) + 8 /* typical path trace len */ );
  msg.flags = htons(0x0008);
  msg.clockid = htobe64(CLOCK_ID);
  msg.sport = htons(1);
  msg.control = 5;
  msg.gcc = 248;
  msg.gca = 0x22;
  msg.prio = 128;
  msg.variance = htons(16000);
  msg.prio2 = 128;
  msg.tsc = 0xa0;
  msg.pt = htons(0x0008);
  msg.ptlen = 0xffff;
  
  if(argc != 2) {
    printf("Usage: %s if_name\n", argv[0]);
    return(1);
  }

  ret_val = 0;
  sock = socket(PF_PACKET, SOCK_DGRAM, 0);
  
  if(sock < 0) {
    perror("socket");
    return(1);
  }

  memset(&req, 0, sizeof(req));
  snprintf(req.ifr_name, sizeof(req.ifr_name), "%s", argv[1]);
  
  if(ioctl(sock, SIOCGIFHWADDR, &req) < 0) {
    perror("ioctl");
    return(1);
  }

  memcpy(hwaddr, &(req.ifr_hwaddr.sa_data), 6);
  hwaddr[6] = 0;
  printf("HWaddr: %02x:%02x:%02x:%02x:%02x:%02x\n",
	 hwaddr[0], hwaddr[1], hwaddr[2],
	 hwaddr[3], hwaddr[4], hwaddr[5]);

  if(ioctl(sock, SIOCGIFINDEX, &req) < 0) {
    perror("ioctl");
    return(1);
  }

  printf("ifidx = %d\n", req.ifr_ifindex);

  memset(&addr, 0, sizeof(addr));
  addr.sll_family = AF_PACKET;
  addr.sll_ifindex = req.ifr_ifindex;
  addr.sll_protocol = htons(PTP_ETHERTYPE);
  addr.sll_halen = ETH_ALEN;
  
  if(bind(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
    perror("bind");
    ret_val = 1;
  }

  for(i = 0; i < 1000000; i++) {
    int len;

    len = announce(sock, req.ifr_ifindex, &msg);

    if(len < 0) {
      fprintf(stderr, "announce: %s\n", strerror(-len));
    }
    
  }
  /*
  while(1) {
    unsigned char buf[1600];
    int len;
    
    len = read(sock, buf, sizeof(buf));

    if(len < 0) {
      perror("read");
      break;
    }

    printf("Recv: %d bytes\n", len);
  }
  */
  close(sock);
  return(ret_val);
}
