/*
 * Discover devices in an AVB network
 * Copyright (C) 2016 Matthias Kruk
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. 
 */

#include <sys/socket.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <net/ethernet.h>
#include <arpa/inet.h>
#include <netpacket/packet.h>
#include <sys/epoll.h>
#include <getopt.h>
#include <errno.h>
#include <endian.h>
#include <time.h>

#define PTP_ETHERTYPE 0x88F7

#define MODE_INTERACTIVE 0
#define MODE_SCRIPT      1

int mode = MODE_INTERACTIVE;

struct alist {
    unsigned char addr[6];
    struct alist *next;
};

#define SCRIPT (mode == MODE_SCRIPT)

static struct alist *addrs = NULL;

int addr_seen(const unsigned char *addr)
{
    struct alist *cur;

    for(cur = addrs; cur; cur = cur->next) {
	if(memcmp(cur->addr, addr, 6) == 0) {
	    return(1);
	}
    }
  
    return(0);
}

int addr_add(const unsigned char *addr)
{
    struct alist *na;

    if(!(na = malloc(sizeof(*na)))) {
	return(1);
    }

    memcpy(na->addr, addr, 6);

    if(!addrs) {
	addrs = na;
    } else {
	struct alist *cur;

	for(cur = addrs; cur->next; cur = cur->next);
	cur->next = na;
    }

    return(0);
}

static int ethaddrstr(char *dst, const size_t dsize, const void *src, const size_t slen)
{
    const unsigned char *addr = src;
    
    if(slen < 6 || dsize < 17) {
	errno = EINVAL;
	return(-1);
    }

    return(snprintf(dst, dsize, "%02X:%02X:%02X:%02X:%02X:%02X", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]));
}

static int handle_msg(int sock, const char *msg, size_t len, struct sockaddr_ll *src)
{
    char addrstr[32];
    size_t i;
    
    if(len < ETHER_HDR_LEN) {
	errno = EBADMSG;
	return(-1);
    }

    if(!addr_seen(src->sll_addr)) {
	ethaddrstr(addrstr, sizeof(addrstr), &(src->sll_addr), sizeof(src->sll_addr));
	if(SCRIPT) {
	    printf("%s\n", addrstr);
	    fflush(stdout);
	} else {
	    printf("Discovered peer: %s\n", addrstr);
	}

	addr_add(src->sll_addr);
    }
    
    return(0);
}

static void usage(const char *argv0)
{
    printf("Usage: %s [OPTIONS]\n"
	   "\n"
	   "Options:\n"
	   " -i <iface>  Use interface <iface>\n"
	   " -t <timeo>  Stop after <timeo> seconds\n"
	   " -s          Generate script-friendly output\n",
	   argv0);

    return;
}

static time_t now(void)
{
    return(time(NULL));
}

int main(int argc, char *argv[])
{
    struct sockaddr_ll addr;
    struct epoll_event ev;
    struct ifreq req;
    unsigned char hwaddr[6];
    unsigned char buffer[ETHERMTU];
    ssize_t len;
    int sock, epfd;
    int ret_val, i;
    char *iface;
    time_t timeo;
    time_t startup;
    
    iface = NULL;
    ret_val = 0;
    timeo = -1;
    
    while((i = getopt(argc, argv, "i:t:sh")) >= 0) {
	switch(i) {
	case 'i':
	    iface = optarg;
	    break;
        case 's':
	    mode = MODE_SCRIPT;
	    break;
	case 't':
	    timeo = atoi(optarg);
	    break;
	default:
	case 'h':
	    usage(argv[0]);
	    return(1);
	}
    }

    if(!iface) {
	printf("Missing argument: -i\n");
	usage(argv[0]);
	return(1);
    }
    
    sock = socket(PF_PACKET, SOCK_DGRAM, 0);
  
    if(sock < 0) {
	perror("socket");
	return(1);
    }

    memset(&req, 0, sizeof(req));
    snprintf(req.ifr_name, sizeof(req.ifr_name), "%s", iface);
  
    if(ioctl(sock, SIOCGIFHWADDR, &req) < 0) {
	perror("ioctl");
	return(1);
    }

    memcpy(hwaddr, &(req.ifr_hwaddr.sa_data), 6);
    
    if(!SCRIPT) {
	printf("Using iface `%s', HWaddr: %02x:%02x:%02x:%02x:%02x:%02x\n", iface, 
	       hwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);
    }

    if(ioctl(sock, SIOCGIFINDEX, &req) < 0) {
	perror("ioctl");
	return(1);
    }

    if(!SCRIPT) {
	printf("ifidx = %d\n", req.ifr_ifindex);
    }

    memset(&addr, 0, sizeof(addr));
    addr.sll_family = AF_PACKET;
    addr.sll_ifindex = req.ifr_ifindex;
    addr.sll_protocol = htons(PTP_ETHERTYPE);
    addr.sll_halen = ETH_ALEN;
  
    if(bind(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
	perror("bind");
	return(1);
    }

    if((epfd = epoll_create(1)) < 0) {
	perror("epoll_create");
	return(1);
    }

    memset(&ev, 0, sizeof(ev));
    ev.events = EPOLLIN;
    ev.data.fd = sock;
    
    if(epoll_ctl(epfd, EPOLL_CTL_ADD, sock, &ev) < 0) {
	perror("epoll_ctl");
	return(1);
    }

    startup = now();

    while(1) {
	i = epoll_wait(epfd, &ev, 1, 1000);

	if(i > 0) {
	    if(ev.events & EPOLLIN) {
		socklen_t slen = sizeof(addr);
	      
		len = recvfrom(sock, buffer, sizeof(buffer), 0, (struct sockaddr*)&addr, &slen);

		if(len < 0) {
		    perror("read");
		    break;
		} else if(len == 0) {
		    close(sock);
		    break;
		}
		
		if(handle_msg(sock, buffer, len, &addr) < 0) {
		    break;
		}
	    } else if(ev.events & EPOLLERR || ev.events & EPOLLHUP) {
		break;
	    }
	}

	if(timeo >= 0 && now() - startup > timeo) {
	    break;
	}
    }

    close(sock);
    close(epfd);

    return(ret_val);
}
