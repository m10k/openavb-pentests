/*
 * Fuzz MVRP messages that are unknown to mrpd but yet parsed
 * Copyright (C) 2016 Matthias Kruk
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. 
 */

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include "common.h"
#include <arpa/inet.h>

static void usage(const char *argv0)
{
  printf("Usage: %s [OPTIONS]\n\n"
	 "Supported options:\n"
	 "  -i <iface>   Use network interface <iface>\n"
	 "  -h           Display this text\n",
	 argv0);
  return;
}

int main(int argc, char *argv[])
{
  char buf[1024];
  mrp_t *msg;
  char *iface = NULL;
  unsigned int k, l;
  int s;
  ssize_t len;
  unsigned long long int total_msgs;
  
  while((s = getopt(argc, argv, "i:h")) >= 0) {
    switch(s) {
    case 'i':
      iface = optarg;
      break;
    default:
    case 'h':
      usage(argv[0]);
      return(1);
      break;
    }
  }

  if(!iface) {
    printf("Missing commandline parameter -i\n");
    usage(argv[0]);
    return(1);
  }
  
  s = net_socket(PROTO_MVRP, iface);

  if(s < 0) {
    perror("net_socket");
    return(1);
  }

  total_msgs = 0;

  for(k = 0; k < 0xff; k++) {
    for(l = 0; l < 0xffff; l++) {
      mrp_msg_t *smsg;
      uint16_t data;
      
      msg = mrp_new(MVRP_VER + 1); /* unknown version */
      smsg = mrp_msg_new(MVRP_VID_TYPE + 1, k); /* unknown message type */
      data = l;

      mrp_append(msg, smsg);
      mrp_msg_append(smsg, &data, sizeof(data));
      
      len = mrp_raw(msg, buf, sizeof(buf));

      if(len < 0) {
	perror("mrp_raw");
      } else if(mrp_send(s, buf, len) < 0) {
	perror("net_write");
      }

      mrp_free(msg);
      total_msgs++;
    }
  }
/*
  for(i = 0; i <= 0xff; i++) {
    printf("ver = 0x%02x\n", i);
    for(j = 0; j <= 0xff; j++) {
      printf("\tmsg_type = 0x%02x\n", j);
      for(k = 0; k <= 0xff; k++) {
	printf("\tattr_len = 0x%02x\n", k);
	for(l = 0; l <= 0xffff; l++) {
	  msg = mmrp_new(i);

	  mmrp_msg_append(msg, j, k, l);
	  
	  len = mmrp_raw(msg, buf, sizeof(buf));

	  if(len < 0) {
	    perror("mmrp_raw");
	  }

	  if(mmrp_send(s, buf, len) < 0) {
	    perror("net_write");
	    break;
	  }

	  mmrp_free(msg);
	  total_msgs++;
	}  
      }
    }
  }
*/
  printf("%llu messages sent.\n", total_msgs);
  
  net_close(s);
  return(0);
}
